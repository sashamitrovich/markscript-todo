/// <reference path="./config.d.ts"/>
/// <reference path="./documents.d.ts"/>
/// <reference path="./graphs.d.ts"/>
/// <reference path="./patch.d.ts"/>
/// <reference path="./query.d.ts"/>
/// <reference path="./resources.d.ts"/>
/// <reference path="./transactions.d.ts"/>
/// <reference path="./values.d.ts"/>

declare module 'marklogic' {
  interface ResultProvider<R> {
    result(resolve: (value?: R | Promise<R>) => void, reject: (reason?: any) => void): Promise<R>
    stream(): NodeJS.ReadWriteStream
  }

  interface ConnectionParams {
    host: string
    port: number
    database?: string
    user: string
    password: string
    authType?: string
    ssl?: string
    agent?: any
  }

  interface Variables {
    [key:string]: string|number|boolean
  }

  interface ServerExec {
    /**
     * Evaluates JavaScript on the server; the user for the database client must have
     * permission to evaluate code on the server and, in addition, permission
     * to execute the actions performed by the source; takes a configuration object
     * with the following named parameters or, as a shortcut, the source
     * with or without variables.
     * @method ServerExec#eval
     * @param {string} source - the JavaScript source code
     * @param {object} [variables] - an object in which each property has
     * a variable name as a key and a number, string, or boolean value
     * @param {string|transactions.Transaction}  [txid] - a string
     * transaction id or Transaction object identifying an open
     * multi-statement transaction
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback that receives the response
     */
    eval: <U>(source: string, variables?: Variables, txid?: string|transactions.Transaction) => ResultProvider<U>
    /**
     * Evaluates XQuery on the server; the user for the database client must have
     * permission to evaluate code on the server and, in addition, permission
     * to execute the actions performed by the source; takes a configuration object
     * with the following named parameters or, as a shortcut, the source
     * with or without variables.
     * @method ServerExec#xqueryEval
     * @param {string} source - the XQuery source code
     * @param {object} [variables] - an object in which each property has
     * a variable name as a key and a number, string, or boolean value; the key
     * may be a namespaced name in Clark notation
     * @param {string|transactions.Transaction}  [txid] - a string
     * transaction id or Transaction object identifying an open
     * multi-statement transaction
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback that receives the response
     */
    xqueryEval: <U>(source: string, variables?: Variables, txid?: string|transactions.Transaction) => ResultProvider<U>
    /**
     * Invokes a JavaScript or XQuery module on the server; the user for the database client
     * must have permission to invoke modules on the server and, in addition, permission
     * to execute the actions performed by the module; takes a configuration object
     * with the following named parameters or, as a shortcut, the path
     * with or without variables.
     * @method serverExec#invoke
     * @param {string} path - the path of the module in the modules database
     * for the REST server; the module must have been installed previously
     * (typically with the {@link config.extlibs#write} function) using
     * a filename extension  (sjs or xqy by default) registered for server
     * JavaScript or XQuery in the server mime types table
     * @param {object} [variables] - an object in which each property has
     * a variable name as a key and a number, string, or boolean value; the key
     * may be in Clark notation for namespaced XQuery variables
     * @param {string|transactions.Transaction}  [txid] - a string
     * transaction id or Transaction object identifying an open
     * multi-statement transaction
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback that receives the response
     */
    invoke: <U>(path: string, variables?: Variables, txid?: string|transactions.Transaction) => ResultProvider<U>
  }

  interface Permissions {
    'role-name':string
    capabilities: string[]
  }

  namespace log {
    interface Logger {
      debug: (...args: any[]) => void
      info: (...args: any[]) => void
      warn: (...args: any[]) => void
      error: (...args: any[]) => void
      silent: (...args: any[]) => void
    }
  }

  /**
   * Creates a database client to make database requests such as writes, reads,
   * and queries. The constructor takes a configuration object with the following
   * named parameters.
   * @function module:marklogic.createDatabaseClient
   * @param {string} [host=localhost] - the host with the REST server for the database
   * @param {number} [port=8000] - the port with the REST server for the database
   * @param {string} [database] - the name of the database to access, defaulting
   * to the database for the AppServer on the port
   * @param {string} user - the user with permission to access the database
   * @param {string} password - the password for the user with permission to access
   * the database
   * @param {enum} [authType=digest] - the authentication type of digest or basic
   * @param {boolean} [ssl=false] - whether the REST server uses SSL; when true,
   * the connection parameters can include the
   * {@link http://nodejs.org/api/https.html#https_https_request_options_callback|supplemental
   * HTTPS options} specifiable for the node.js tls.connect() function.
   * @param {object} [agent] - defaults to a connection pooling agent
   * @returns {DatabaseClient} a client for accessing the database
   * as the user
   */
  interface DatabaseClient extends ServerExec {
    // connectionParams: ConnectionParams
    //
    /**
     * Creates one or more JSON documents for a collection; takes a collection name string and
     * the content for one or more JSON documents (or an array of content). The
     * server assigns uri identifiers to the documents created with the content.
     * The {@link documents#write} function is less simple but more complete,
     * accepting a uri identifier and metadata (such as multiple collections)
     * and optionally transforming each document on the server.
     * @method DatabaseClient#createCollection
     * @param {string}  collection - the name of the collection for the documents
     * @param {object|object[]} content - the objects with the content for the
     * documents
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback receiving an array of uri strings for the created documents.
     */
    createCollection: (collection: string, content: any) => ResultProvider<string[]>

    /**
     * Probes whether a document exists; takes a uri string identifying the document.
     * The {@link documents#probe} function is less simple but more complete,
     * returning an object with additional information.
     * @method DatabaseClient#probe
     * @param {string}  uri - the uri for the database document
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback that receives a boolean.
     */
    probe: (uri: string) => ResultProvider<boolean>

    /**
     * Executes a query to retrieve the content of documents in a collection,
     * optionally adding a query built by a {@link queryBuilder} to retrieve
     * a subset of the collection documents.
     * The {@link documents#query} function is less simple but more complete,
     * potentially transforming documents on the server and returning
     * an envelope object for each document with the uri and metadata
     * as well as the content.
     * an object for each document with additional information.
     * @method DatabaseClient#queryCollection
     * @param {string}  collection - the name of the document collection
     * @param {object}  [query] - a query built by a {@link queryBuilder}
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback that receives an array with the content of the
     * documents.
     */
    queryCollection: (collection: string, query: any) => ResultProvider<Object[]>

    /**
     * Reads one or more documents; takes one or more uri strings or
     * an array of uri strings. The {@link documents#read} function
     * is less simple but more complete, potentially transforming
     * documents on the server and returning an envelope object for
     * each document with the uri and metadata as well as the content.
     * @method DatabaseClient#read
     * @param {string|string[]}  uris - the uri string or an array of uri strings
     * for the database documents
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback that receives an array with the content of the documents.
     */
    read: (uris: string|string[]) => ResultProvider<Object[]>

    /**
     * Removes one or more database documents; takes one or more uri strings
     * identifying the document.
     * The {@link documents#remove} function is less simple but more complete.
     * @method DatabaseClient#remove
     * @param {string|string[]}  uris - the uri string or an array of uri strings
     * identifying the database documents
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback that receives the uris identifying the removed documents.
     * For backward compatibility, if a string ispassed, the uri is returned
     * as a string, but in the next major release, the uri will be return
     * as an array with one string.
     */
    remove: (uri: string) => ResultProvider<string>

    /**
     * Removes all documents in a collection; takes the uri string identifying
     * the collection.
     * The {@link documents#removeAll} function is less simple but more complete,
     * supporting deleting a directory or all documents in the database.
     * @method DatabaseClient#removeCollection
     * @param {string}  collection - the collection whose documents should be
     * deleted
     * @returns {ResultProvider} an object with a result() function takes
     * a success callback that receives the uri string identifying the removed
     * collection.
     */
    removeCollection: (collection: string) => ResultProvider<string>

    /**
     * Inserts or updates one or more documents for a collection; takes a collection name
     * string and an object that maps document uris to document content.
     * The {@link documents#write} function is less simple but more complete,
     * accepting a uri identifier and metadata (such as multiple collections)
     * and optionally transforming each document on the server.
     * @method DatabaseClient#writeCollection
     * @param {string}  collection - the name of the collection for the documents
     * @param {object} documents - an object in which every key is the uri string
     * for a document and every value is the content for the document
     * @returns {ResultProvider} an object whose result() function takes
     * a success callback receiving an array of uri strings for the written documents.
     */
    writeCollection: (collection: string, documents: {[uri:string]:any}) => ResultProvider<string[]>

    release: () => void

    /**
     * Provides functions that write, read, query, or perform other operations
     * on documents in the database. As a convenience, the same functions are
     * provided on the database client.
     * @name documents
     * @memberof! DatabaseClient#
     * @type {documents}
     */
    documents: documents.Documents

    /**
     * Provides functions that open, commit, or rollback multi-statement
     * transactions.
     * @name transactions
     * @memberof! DatabaseClient#
     * @type {transactions}
     */
    transactions: transactions.Transaction

    /**
     * Provides functions that read, write, merge, remove, list, or query
     * with SPARQL on triple graphs.
     * @name graphs
     * @memberof! DatabaseClient#
     * @type {graphs}
     */
    graphs: graphs.Graphs

    /**
     * Provides functions that submit get, put, post, or remove requests
     * to resource service extensions.
     * @name resources
     * @memberof! DatabaseClient#
     * @type {resources}
     */
    resources: resources.Resources

    /**
     * Provides functions that submit values queries to project
     * tuples (rows) of values from documents.
     * @name values
     * @memberof! DatabaseClient#
     * @type {values}
     */
    values: values.Values

    /**
     * Provides access to namespaces that configure the REST server for the client.
     * The client must have been created for a user with the rest-admin role.
     * @name config
     * @memberof! DatabaseClient#
     * @property {config.extlibs} extlibs - provides functions that
     * maintain the extension libraries on the REST server
     * @property {config.patch.replace} patch.replace - provides functions that
     * maintain patch replacement libraries on the REST server
     * @property {config.query.custom} query.custom - provides functions that
     * maintain custom query binding or facet extensions on the REST server
     * @property {config.query.snippet} query.snippet - provides functions that
     * maintain query snippet extensions on the REST server
     * @property {config.resources} resources - provides functions that
     * maintain resource service extensions on the REST server
     * @property {config.serverprops} serverprops - provides functions that
     * modify the properties of the REST server
     * @property {config.transforms} transforms - provides functions that
     * maintain transform extensions on the REST server
     */
    config: {
      extlibs: config.ExtLibs
      patch: {
        replace: config.ExtLibs
      }
      query: {
        custom: config.ExtLibs
        snippet: config.ExtLibs
      }
      resources: config.Resources
      serverprops: config.RESTServerProperties
      transforms: config.Transforms
    }

    /**
     * Supplies a logger to use for database interactions or, instead, takes
     * a logging level from the debug|info|warn|error|silent enumeration (where silent
     * is the initial setting) for the default console logger.
     * @method DatabaseClient#setLogger
     * @param {object}  logger - an object providing debug(), info(), warn(), and error()
     * logging methods such as a logger provided by the
     * {@link https://github.com/trentm/node-bunyan|Bunyan} or
     * {@link https://github.com/flatiron/winston|Winston} logging libraries.
     * @param {boolean}  [isErrorFirst] - whether an error should be logged as the first parameter;
     * must be provided as true for Bunyan (but not for Winston); defaults to false
     */
    setLogger: (logger: log.Logger, isErrorFirst?: boolean) => void
  }

  /**
   * A client object configured to write, read, query, and perform other
   * operations on a database as a user. The client object is
   * created by the {@link module:marklogic.createDatabaseClient} function.
   * @namespace DatabaseClient
   * @borrows serverExec#eval       as DatabaseClient#eval
   * @borrows serverExec#xqueryEval as DatabaseClient#xqueryEval
   * @borrows serverExec#invoke     as DatabaseClient#invoke
   */
  export function createDatabaseClient(connectionParams: ConnectionParams): DatabaseClient

  /**
   * A factory for creating a document query builder.
   * @function
   * @returns {queryBuilder} a helper for defining a document query
   */
  export const queryBuilder: query.Query

  /**
   * A factory for creating a document patch builder
   * @function
   * @returns {patchBuilder} a helper for defining a document patch
   */
  export const patchBuilder: patch.PatchBuilder

  /**
   * A factory for creating a values builder
   * @function
   * @returns {valuesBuilder} a helper for defining a query
   * to project tuples (rows) of values from documents
   */
  export const valuesBuilder: values.ValuesBuilder
}
