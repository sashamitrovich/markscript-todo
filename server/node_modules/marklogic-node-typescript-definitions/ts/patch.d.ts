declare module 'marklogic' {
  namespace patch {
    /**
     * An operation as part of a document patch request.
     * @typedef {object} patchBuilder.PatchOperation
     */
    interface PatchOperation {
      __$_patch_PatchOperation
    }

    /**
     * The specification for a library of replacement functions as returned by
     * the {@link patchBuilder#library} function.
     * @typedef {object} patchBuilder.LibraryParam
     */
    interface LibraryParam {
      __$_patch_LibraryParam
    }

    /**
     * The specification for applying a function to produce the content for a
     * {@link patchBuilder#replace} or {@link patchBuilder#replaceInsert}
     * operation.
     * @typedef {object} patchBuilder.ApplyDefinition
     */
    interface ApplyDefinition {
      __$_patch_ApplyDefinition
    }

    /**
     * The specification for whether select and context paths use
     * XPath or JSONPath as returned by
     * the {@link patchBuilder#pathLanguage} function.
     * @typedef {object} patchBuilder.PathLanguageParam
     */
    interface PathLanguageParam {
      __$_patch_PathLanguageParam
    }

    /**
     * A helper for building the definition of a document patch. The helper is
     * created by the {@link module:marklogic.patchBuilder} function.
     * @namespace patchBuilder
     */
    interface PatchBuilder {
      /**
       * Builds an operation to remove a JSON property or XML element or attribute.
       * @method
       * @memberof patchBuilder#
       * @param {string}  select - the path to select the fragment to remove
       * @param {string}  [cardinality] - a specification from the ?|.|*|+
       * enumeration controlling whether the select path must match zero-or-one
       * fragment, exactly one fragment, any number of fragments (the default), or
       * one-or-more fragments.
       * @returns {patchBuilder.PatchOperation} a patch operation
       */
      remove(select:string, cardinality?:string):PatchOperation

      /**
       * Builds an operation to insert content.
       * @method
       * @memberof patchBuilder#
       * @param {string}  context - the path to the container of the inserted content
       * @param {string}  position - a specification from the before|after|last-child
       * enumeration controlling where the content will be inserted relative to the context
       * @param           content - the inserted object or value
       * @param {string}  [cardinality] - a specification from the ?|.|*|+
       * enumeration controlling whether the context path must match zero-or-one
       * fragment, exactly one fragment, any number of fragments (the default), or
       * one-or-more fragments.
       * @returns {patchBuilder.PatchOperation} a patch operation
       */
      insert(context:string, position:string, cardinality?:string):PatchOperation

      /**
       * Specifies a library supplying functions to apply to existing content
       * to produce the replacement content as part of
       * {@link patchBuilder#replace} or {@link patchBuilder#replaceInsert} operations.
       * The library must be installed as /ext/marklogic/patch/apply/MODULE_NAME.xqy
       * and must have the http://marklogic.com/patch/apply/MODULE_NAME namespace.
       * @method
       * @memberof patchBuilder#
       * @param {string} moduleName - the name of the module with the functions
       * @returns {patchBuilder.LibraryParam} the specification for applying a function
       */
      library(moduleName:string):LibraryParam

      /**
       * Specifies a function to apply to produce the replacement or insertion
       * content for a {@link patchBuilder#replace} or {@link patchBuilder#replaceInsert}
       * operation.
       * @method
       * @memberof patchBuilder#
       * @param {string} functionName - the name of the function to apply
       * @param ...args - arguments to pass to the applied function; you can use the
       * datatype() function to specify an atomic type in the list prior to a value
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      apply(functionName:string, ...args:any[]):ApplyDefinition

      /**
       * Adds a number to the existing value to produce the replace content
       * for a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {number} number - the number to add
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      add(number:number):ApplyDefinition

      /**
       * Subtracts a number from the existing value to produce the replace content
       * for a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {number} number - the number to subtract
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      subtract(number:number):ApplyDefinition

      /**
       * Multiplies the existing value by a number to produce the replace content
       * for a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {number} multiplier - the number to multiply by
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      multiplyBy(multiplier:number):ApplyDefinition

      /**
       * Divides the existing by a number to produce the replace content
       * for a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {number} divisor - the number to divide by
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      divideBy(divisor:number):ApplyDefinition

      /**
       * Prepends a value to the existing value for a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {string} prepended - the string to prepend
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      concatBefore(prepended:string):ApplyDefinition

      /**
       * Appends a value to the existing value for a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {string} appended - the string to append
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      concatAfter(appended:string):ApplyDefinition

      /**
       * Prepends and appends values to the existing value for
       * a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {string} prepended - the string to prepend
       * @param {string} appended - the string to append
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      concatBetween(prepended:string, appended:string):ApplyDefinition

      /**
       * Trims a leading substring from the existing value for
       * a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {string} start - the leading string to trim
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      substringAfter(start:string):ApplyDefinition

      /**
       * Trims a trailing substring from the existing value for
       * a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {string} end - the trailing string to trim
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      substringBefore(end:string):ApplyDefinition

      /**
       * Applies a regular expression to the existing value to produce a new value for
       * a {@link patchBuilder#replace} operation.
       * @method
       * @memberof patchBuilder#
       * @param {string} match - the expression extracting parts of the existing value
       * @param {string} end - the expression to assembling the extracted parts into
       * a replacement value
       * @param {string} [flags] - the flags changing the regex operation
       * @returns {patchBuilder.ApplyDefinition} the specification for applying a function
       */
      replaceRegex(match:string, end:string, flags?:string):ApplyDefinition

      /**
       * Builds an operation to replace a JSON property or XML element or attribute.
       * @method
       * @memberof patchBuilder#
       * @param {string}  select - the path to select the fragment to replace
       * @param           [content] - the object or value replacing the selected fragment or
       * an {@link patchBuilder.ApplyDefinition} specifying a function to apply to the selected
       * fragment to produce the replacement
       * @param {string}  [cardinality] - a specification from the ?|.|*|+
       * enumeration controlling whether the select path must match zero-or-one
       * fragment, exactly one fragment, any number of fragments (the default), or
       * one-or-more fragments.
       * @returns {patchBuilder.PatchOperation} a patch operation
       */
      replace(select:string, content?:any, cardinality?:string):PatchOperation

      /**
       * Builds an operation to replace a fragment if the fragment exists and insert
       * the new content if the fragment doesn't exist.
       * The content argument is optional if an apply argument is provided and
       * required otherwise.
       * @method
       * @memberof patchBuilder#
       * @param {string}  select - the path to select the fragment to replace
       * @param {string}  context - the path to the container for inserting the content
       * when the select path doesn't match
       * @param {string}  position - a specification from the before|after|last-child
       * enumeration controlling where the content will be inserted relative to the context
       * @param           [content] - the object or value replacing the selected fragment or,
       * alternatively, inserting within the context  or
       * an {@link patchBuilder.ApplyDefinition} specifying a function to generate the
       * replacement for the selected fragment or the inserted content
       * @param {string}  [cardinality] - a specification from the ?|.|*|+
       * enumeration controlling whether the select or context path must match zero-or-one
       * fragment, exactly one fragment, any number of fragments (the default), or
       * one-or-more fragments.
       * @returns {patchBuilder.PatchOperation} a patch operation
       */
      replaceInsert(select:string, context:string, content?:any, cardinality?:string):PatchOperation

      /**
       * Specifies whether the language used in context and select paths
       * for the document patch is XPath or JSONPath. XPath may be used
       * for either JSON or XML documents and is the default path language.
       * JSONPath may only be used for JSON documents. A document patch
       * cannot contain a mix of XPath and JSONPath.
       * @method
       * @memberof patchBuilder#
       * @param {string} language - one of the enumeration xpath|jsonpath
       * @returns {patchBuilder.PathLanguageParam} the specification for the path language
       */
      pathLanguage(language:string):PathLanguageParam
    }
  }
}
